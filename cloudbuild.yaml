steps:
  # Step 1: Install dependencies
  - name: node:20
    entrypoint: npm
    args: ["ci"]
    id: install

  # Step 2: Lint code (code quality checks)
  - name: node:20
    entrypoint: npm
    args: ["run", "lint"]
    id: lint
    waitFor: ["install"]

  # Step 3: Deploy to App Engine
  # Note: Migrations run locally before commit as part of development workflow
  # Database schema is managed through version control and local testing
  - name: gcr.io/cloud-builders/gcloud
    args: ["app", "deploy", "app.yaml", "--quiet"]
    id: deploy
    waitFor: ["lint"]

timeout: "1200s"

options:
  logging: CLOUD_LOGGING_ONLY

# Service account permissions required:
# - roles/secretmanager.secretAccessor (for accessing db-password secret at runtime)
# - roles/appengine.appAdmin (for deploying to App Engine)

# Development Workflow:
# 1. Local: npm test (validate connection)
# 2. Local: npm run migrate (update schema)
# 3. Local: npm start (test application)
# 4. Commit & Push (triggers this CI/CD pipeline)
# 5. CI/CD: install → lint → deploy
# 6. App Engine: Fetches secrets at runtime, connects to Cloud SQL

# Note: Cloud Build containers don't have Cloud SQL Unix socket access.
# All database operations (testing, migrations) are performed locally with Cloud SQL Proxy.
# CI/CD focuses on code quality and deployment automation.
